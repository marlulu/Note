- 单一职责原则
> 一个类或方法只包含一个完整的职责.  
> - 就一个类而言，应该仅有一个引起它变化的原因.  
> - 将类的不同职责分离出来.  
> - 将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中.  
> - 实现高内聚低耦合.
- 开闭原则 (最重要)
> 软件实体扩展应该对外开放，修改应该对外关闭
> - 系统设计时使用抽象化设计，将具体的行为转移到其子类进行实现。
> - 不修改任何源代码的基础上完成功能的扩展
> - 可以通过接口，抽象类机制定义系统的抽象层，再通过具体类实现业务功能
- 里氏代换原则
> 所有引用基类的地方必须能够透明使用其子类对象
> - 使用多态的特性，通过子类扩展父类
> - 将父类设计为抽象类或者接口，让子类进行继承或者实现父类
> - 尽量使用父类类型对对象进行定义，在运行时再确定其子类类型，用子类对象来替换父类对象。
- 依赖倒转原则
> 高层模块不应该依赖低层模块，它们都应该依赖抽象，抽象不应该依赖于细节，细节应该依赖于抽象
> - 面向对象设计的主要实现机制，要求面向接口编程，不要针对实现编程
> - 在代码中传递参数或在关联关系中尽量使用层次高的抽象层类，一个具体类应当只实现接口或抽象类中声明过的方法。
> - 使用接口，抽象类进行声明，而不是具体的类。
> - 需要针对抽象层编程，集体类的对象通过依赖注入（构造方法注入，Set方法注入，接口注入）
- 接口隔离原则
> 客户端不应该依赖那些它不需要的接口
> - 语言中具体的接口被 Interface 关键词修饰，接口应该尽量细化，根据职责的不同分别定义不同的方法，确保使用起来较为方便，并都承担单一角色。
> - 接口的方法应该尽量少，每个接口中只包含一个客户端(业务逻辑类)所需要的方法即可，为不同客户端提供宽窄不同的接口。
> - 一个类型所具有的方法特性的集合，是一种逻辑上的概念，可以理解为角色，一个接口只能代表一种角色，每个角色都有它特定的一个接口。
- 合成复用原则
> 优先使用对象组合，而不是通过继承来达到复用的目的。
> - 原则就是在一个新的对象中通过组合或关联关系，来使用一些已有的对象，使之陈伟新对象的一部分，新对象通过委派调用已有对象的方法达到复用的目的
> - 白箱复用
> > 继承复用会破坏系统的封装性，继承会将父类的实现细节暴露给子类，父类的某些内部细节对子类来说可见，故继承复用又称为白箱复用，若父类发生了变化，子类的实现也不得不发生变化。
> - 黑箱复用
> > 组合或关联关系复用，是将已有对象纳入新的对象之中，因此新对象可以调用已有对象的功能，而成员对象的内部实现细节对于新对象来说不可见，故称为黑箱复用。  
> 成员对象的内部变化对新对象的影响相对不大，可以在新对象中根据实际需要有选择性的调用尘缘对象的操作。
> - 当两个类之间若存在“某个角色具有某项责任”的关系时，则应该使用组合或者关联关系复用，若存"一个类是另一个类的一种"的关系时，则可以使用继承复用。
- 迪米特法则
> 每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。  
> 降低系统的耦合度，使类与类之间保持松散的耦合关系。
> - 一个关键实体应当尽可能少的与其他实体发生相互作用，若系统符合度米特法则，当某一个模块发生变动时，就会尽量少的影响其他模块，扩展相对容易。
> - 可以发生交互作用的对象应当仅包含以下几种:
>   - 当前对象本身(this)
>   - 以参数的形式传入到当前对象方法中的对象
>   - 当前对象的成员对象(如果成员对象是集合,则包含集合中的所有对象)
>   - 当前对象所创建的对象
> - 在应用迪米特法则时，任何对象都需要满足上面的条件之一，只能与以上对象发生交互，如果需要调用另一个对象的方法，可以通过引入一个合理的第三者来降低现有对象之间的耦合度
> - 在系统设计中运用迪米特法则时应注意以下几点:
>   - 在类的划分上，应当尽量创建松耦合的类，类之间耦合度越低，越有利于复用。
>   - 在类的结构设计上，每个类都应当尽量降低其成员变量和成员函数的访问权限。
>   - 在类的设计上，只要有可能，该类型应当被final修饰符修饰。
>   - 在其他类的引用上，一个对象对其他对象的引用应当降到最低。