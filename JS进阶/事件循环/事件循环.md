# 事件循环

----

## 事件循环机制

JavaScript的执行过程中，处理依靠函数调用栈来搞定函数的执行机制，还依靠任务队列来搞定另外一些代码的执行，整个执行过程被称为事件循环过程。

任务队列分为两个

**宏任务：**
+ script（整体代码）
+ setTimeout
+ setInterval
+ setImmediate
+ I/O
+ UI render

**微任务：**
+ process.nextTick
+ Promise
+ Async/Await
+ MutationObserver

先执行宏任务，然后执行宏任务产生的微任务，若为任务执行中产生了新的微任务，则继续执行微任务，微任务执行完后，再回到宏任务中进行下一轮循环。

#async/await 执行顺序

1. 若 await 后面直接跟的为一个变量，相当于直接把 await 后面的代码注册为一个微任务。然后跳出 async1 函数，执行其他代码，当遇到 promise 函数的时候，会注册 promise.then() 函数到微任务队列，此时微任务队列里面已经存在await后面的微任务了，故会先执行 await 后面的代码，在执行 async1 函数后面注册的微任务代码。
2. 若 await 后面跟的是一个异步函数的调用。执行完 await 后并不先把 await 后面的代码注册到微任务队列中，而是执行完 await 之后，跳出 async 函数，执行其他代码，然后遇到 promise 的时候，把 promise.then注册为微任务。其他代码执行完后，需要回到 async去执行剩下的代码，然后把 await 后面的代码注册到为队列中，注意的是前面已经注册有了微任务了，会先执行前面注册了的微任务。

**取消事件轮询的原因**
+ 首先，事件轮询是一种通过不断地检查事件队列来处理事件的机制。但是，这种机制会占用大量的CPU资源，造成性能问题。
+ 此外，事件轮询可能会导致延迟，因为需要等待每一次循环才能处理下一个事件。
+ 为了改善性能和增加代码的响应能力，现代的JavaScript引擎引入了异步编程模型。通过使用回调函数、Promise对象、async/await等机制，可以实现非阻塞的事件处理。 这种方式能够更好地利用系统资源，并且能够在事件发生时立即处理，而不需要等待事件轮询。
+ 另外，事件轮询也容易导致死循环和线程阻塞等问题。取消事件轮询可以避免这些潜在的问题。
+ 
综上所述，取消事件轮询是为了提高性能、提高代码的响应能力，并避免潜在的问题。