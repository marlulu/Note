一、作用域
- 定义和作用
  - 定义：变量或函数存在的范围，函数身上的属性 [[scope]]，用于存储函数中的有效标识符
  - 作用：隔离变量
- 形成时机
  - 函数作用域：在函数创建时形成
- 函数本身的作用域
  - 函数声明时所在的作用域，与函数调用时所有的作用域无关
- 局部变量和全局变量
  - 局部变量：函数内部的变量
  - 全局变量：任何地方都可访问

- 作用域链
  - 是看当前执行上下文变量环境中的 [outer] 指向确定
    - outer指向的规则是：其词法作用域在哪里，就指向哪里
      - 词法作用域：函数定义时所在的作用域


二、执行上下文
- 本质是一个对象
- 由 变量环境 和 词法环境 组成
  - 变量环境（var声明的变量）
  - 词法环境（let，const声明的变量）

- 全局执行上下文
  - js运行时，首先会进入该环境，不在任何函数中的js代码都位于全局执行上下文
  - 只能存在一个，位于执行上下文栈的最底部
  - 全局执行上下文会做两件事：（1）创建一个全局对象 （2）将this指向这个全局对象
  - 在浏览器环境全局对象是window，在node环境全局对象是global

- 函数执行上下文
  - 每次调用一个函数，都会生成一个新的函数执行上下文
  - 每个函数都有自己的函数执行上下文，但只有函数被调用时才会被创建
  - 生命周期分为，创建阶段和执行阶段

- 执行上下文栈（函数调用栈）
  - 后进先出的结构，存储代码执行产生的所有执行上下文
  - 具体过程
    - 当JS刚开始运行时，首先产生全局执行上下文，压入栈，位于栈底
    - 每发生一个函数被调用，产生函数执行上下文，压入栈，位于栈顶
    - 当函数执行完，会从执行上下文栈中弹出
    - 继续执行位于栈顶的函数

- 执行上下文的生命周期
> 名词
> 
> VO 变量对象：用于存储变量和函数声明
> 
> Scope Chain 作用域链：用于解析变量的访问权限
  - 创建阶段
    - 创建变量对象
      - 会找出所有的变量声明和函数声明，并将它们添加到变量对象中
      - 函数声明，整个函数会被提升到变量对象中
      - 变量声明只会被声明（初始值为undefined），但不会被赋值
    - 创建作用域链
      - 根据当前执行上下文的词法环境和作用域嵌套关系来建立作用域链
      - 用域链的顶端是当前执行上下文的变量对象，底端是全局上下文的变量对象
    - 确定 this 指向
  - 执行阶段
    - 变量赋值
    - 函数引用

变量对象
- 在函数执行上下文中，变量对象VO用活动对象AO表示
  - AO在进入函数执行上下文时被创建，通过 argument 对象进行初始化
  - 函数执行上下文的，进入函数执行上下文阶段（预编译阶段）代码还未真正执行，此时AO被创建，此时包含的属性有：
    - arguments对象
    - 所有形参
    - 所有函数声明
    - 所有变量声明
    - this
> 活动对象AO和变量对象VO的区别
> 
> 变量对象：在JS环境中无法访问，在进入函数执行上下文阶段，VO才被激活，成为AO
> 
> 活动对象：只有成为活动对象，变量对象的属性和方法才能被访问

变量提升
- 优先级：形参 > 函数声明 > 变量声明
  - 函数名已经存在，则新的覆盖旧的
  - 变量名已经存在，直接跳过变量声明，赋值是正常的赋值
  - 函数提升优先级高于变量提升，且不会被同名变量声明时覆盖，但是会被变量赋值后覆盖。

- 形参赋值大于变量赋值

暂时性死区
- 从块的开始到变量声明之间的区域被称为"暂时性死区"
- 在声明之前访问这些变量会导致引用错误


