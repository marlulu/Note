# 从浏览器接收url到开启网络请求线程

# 1. 多进程的浏览器

- 进程：cpu 资源分配的最小单位
- 线程：cpu 调度的最小单位

进程和线程之间的联系
- 进程和进程之间是相互独立的，都有自己的一部分内存
- 线程是进程的一部分，多个线程在进程中相互合作 
- 一个进程可以由一个或多个线程组成
- 多个线程在同一个进程中共享内存空间中的资源
- 单线程和多线程都是指在一个进程中

浏览器：
- 浏览器是多进程的
- 系统给它的进程分配了内存和资源
- 每打开一个 tab 标签就相当于加了一个进程（有时多个进程可能或合成一个进程）

浏览器包含的进程
1. Browser 进程：浏览器的主进程，只有一个，灌流协调控制整个浏览器运行
   - 管理用户页面，如前进，后退等交互操作。
   - 负责各个页面的管理，创建和销毁其他进程
   - 将 Renderer(渲染进程) 获得的 Bitmap(位图)，绘制到用户界面上
   - 网络资源的管理，下载
   
2. 第三方插件进程
   - 每种插件对应一个进程，仅当插件使用的时候创建。
   - 插件出问题的时候不会影响到主要的浏览器进程或其他标签页
   
3. GPU 进程：主要负责图形相关任务
   - 最多一个，负责 3D 作图
   
4. 浏览器渲染进程：Renderer 进程，内部多线程，通常的浏览器内核
   - 默认每个 tab 页面创建一个，互不影响（有时浏览器会优化，会将多个空白标签页合并为一个进程）
   - 页面渲染，脚本执行，事件处理等，处理成为可视化页面的内容

进程之间的通信
- 首先浏览器进程（Browser进程）接收用户请求，获取页面内容，然后将任务通过 Renderer Host接口传递给 Render进程。
- 然后 Renderer进程接收到消息后，通过解析，交给渲染线程，然后开始渲染，渲染线程接收请求，加载网页并渲染网页（可能需要 Browser进程获取网络资源，GPU进程协助渲染），最后 Renderer进程将结果返回给 Browser进程
- Browser进程将接收到的结果绘制出来

与单进程浏览器相比
- 避免了单个 tab 页崩溃而影响整个浏览器
- 避免了第三方插件崩溃而影响整个浏览器
- 多进程利用了多核的优势，提高了浏览器利用资源的效率
- 增强了安全性。方便使用沙盒模型隔离插件等进程

缺点
- 内存消耗大，每个页面都是一个进程，系统都要分配一个内存
- 进程间的通信可能会导致性能的损失和延迟

沙盒模型：通过将应用程序或进程限制在一个受控的环境中运行。在沙盒中运行的应用程序无法访问系统资源或其他应用程序的数据，防止相互干扰。

# 2. 多线程的浏览器内核
又称浏览器的渲染进程

主要线程
- GUI渲染线程
  - 负责渲染浏览器界面，解析 HTML文档和 CSS样式，构建 DOM树和 CSSOM树，这两个树会合成一个 RenderObject树(渲染树)，然后布局和绘制。
  - 渲染树构建完成就开始绘制，通过遍历渲染树，根据每个节点的样式和位置，将其绘制到页面。
  - 当界面需要重绘或回流，该线程就会执行
    - 重绘：重新绘制页面上发生变化的部分
    - 回流：重新计算页面上所有元素的位置和尺寸
  - GUI线程和 JS引擎线程是互斥的。当 JS引擎线程执行 JS代码时，GUI渲染线程会被挂起（冻结），直到 JS引擎线程空闲为止，这是为了防止 JS代码执行时间过长而导致页面渲染卡顿
    - defer 和异步 async 

- JS引擎线程
  - JS 内核，处理 JS脚本。
  - 基本特征
    - 单线程，一个页面永远只有一个线程在执行 JS脚本代码。
      - 避免DOM操作冲突
      - 简化编程模型：免除了需要处理线程同步的复杂性
      - 简化异步事件的处理机制：通过事件循环和回调函数简化异步事件的处理，只需关注事件的注册和相应的回调函数，无需深入理解复杂的同步机制
    - 异步处理，通过事件循环机制实现异步处理，当有耗时任务可以先挂起，等耗时任务返回结果后再执行。
  - 工作机制
    - 事件循环：会不断检查任务队列中的任务。
    - 任务分类：宏任务和微任务。先宏任务再宏任务中的微任务，再下一个宏任务。
    - 执行上下文：代码执行时的环境，包括变量对象、作用域链和 this指向等。
      - JS引擎首先会对每个加载完成的 JS代码进行语法检验，若语法正确，则进入预编译，则不正确则停止执行该代码块，继续查找并加载下一个代码块。
      - 进入预编译阶段，确定变量对象，作用域链和 this指向。
      - JS引擎按照顺序执行，若遇到同步，立刻执行，异步，挂起，放入任务队列中。

- 事件触发线程
  - 归属于浏览器而不是 JS引擎，用于控制事件循环，主要功能是监听和触发事件。
  - 当 JS引擎执行代码块如 setTimeout中回调函数含有触发事件（或者 UI事件，HTTP请求事件中回调函数含有触发事件等），会将对应的任务添加到事件线程中。
  - 当对应事件符合条件被触发，该线程会把事件添加到待处理队列（任务队列）的队尾，等待 JS引擎处理。
  - 由于 JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理。
  
- 定时器触发线程
  - setInterval 与 setTimeout 所在的线程
  - 浏览器定时计数器不是由 JS引擎计数的（因为 JS引擎是单线程的，若处于阻塞线程会影响计时的准确）
  - 通过单独线程进行计时并处罚定时（计时完毕后，添加到事件队列中，等待 JS引擎执行
  - setTimeout 中低于 4ms的时间间隔算为 4ms

- 网络请求线程（异步http请求线程）
  - 使用 XMLHttpRequest对象发送 HTTP请求时，就会新开一个 HTTP请求线程
  - 当检测到状态变更时，若设置有回调函数，异步线程就会产生状态的变更事件，将这个回调在放入事件队列中，再由 JS引擎执行

线程之间的关系
1. GUI渲染线程与 JS引擎线程互斥。
   - JS是可以操纵 DOM 的，若在修改这些元素的同时渲染，可能会导致渲染线程前后的元素数据不一致
   - GUI更新会被保存在一个队列中等到 JS引擎空闲时被执行。
2. JS阻塞页面加载
   - 因为 GUI渲染线程和 JS引擎线程互斥，故当 JS引擎长时间没运行完，GUI会等待很久，会导致页面的渲染不连贯，有阻塞感。

WebWorker：浏览器后台的一个单独线程，用于处理 JS引擎中需要大量计算的地方，只属于某个页面，不会与其他页面的 Renderer进程共享，是浏览器开的一个位于 Renderer进程下的线程。

SharedWorker：浏览器会为其单独创建一个进程来运行JS程序，是浏览器所有页面共享的，多个 Renderer进程共享使用，浏览器中只存在一个 SharedWorker，由独立的进程管理

浏览器渲染流程（后面单开一章详细探究）
1. 解析 HTML文档生成 DOM树，DOM树就是 HTML的树状表示，每个 DOM节点对应一个 HTML元素 
2. 解析 CSS生成 CSS对象模型
3. 将 DOM树和 CSS对象模型合并，构建渲染树
4. 布局渲染树（Layout），各元素尺寸、位置的计算
5. 绘制渲染树（paint），绘制页面像素信息
6. 浏览器将各图层信息发送给 GPU，GPU会将各图层进行合成，显示出完整的页面
7. 渲染完毕后就是 load事件，然后就是 JS逻辑的处理

图层
- 普通图层：是页面的普通的文档流，我们虽然可以使用绝对定位相对定位来脱离文档流，但是它仍属于默认复合层，都公用同一个绘画上下文对象
- 复合图层：会单独分配系统资源，每个复合图层都有一个独立的绘画上下文对象（当然也会脱离文档流，这样一来，不管复合图层中如何变化，都不会影响默认图层内的重绘重排）
- absolute和硬件加速的区别：
  - absolute虽然可以脱离普通文档流，但无法脱离默认复合层，故不会改变文档流中的render树，但最终绘制的时候，是整个复合层进行绘制，absolute信息发生变化，会影响在整个复合层的绘制。
  - 硬件加速是直接另起一个复合层，它的更改不会影响默认复合层。


先 DOMContentLoad事件，再 load事件

css 不会阻塞 DOM树的解析，但会阻塞 Render树的渲染。
1. 首先 CSS是单独下载线程异步下载的，DOM树的解析和CSS的加载是异步进行的，故不会阻塞解析
2. 若不阻塞，可能会导致 CSS还没加载完成，JS就获取到错误的样式信息进行 DOM树的渲染，当 CSS加载完成后，就会导致重绘或回流。
3. 故当 DOM树解析完成后，需要等到 CSS完全加载完成，然后根据最终的样式渲染 render树。提高性能

微任务由 JS引擎线程维护。宏任务由事件触发线程维护

# 3. 解析URL

解析 URI (统一资源标识符) URL (统一资源定位符) URL 是 URI 的一个子集
URL 大概有这几个部分
1. protocol 协议头，如 http，ftp 等
2. 用户信息（通常不推荐）
3. host 主机域名或 IP 地址
4. port 端口号
5. path 目录路径
6. query 查询参数
7. fragment 片段标识符，# 后面的 hash 值，一般用于定位到某个为止

# 4. 网络请求都是单独的线程

每次网络请求时都需要开辟单独的线程进行，故浏览器会根据协议，开辟一个网络线程，去请求资源