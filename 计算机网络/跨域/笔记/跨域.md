#                   跨域

------
# 前言：跨域与同源策略
### **同源** 
**定义：** 页面的协议，域名和端口都相同，则为同一源，否则为非同一源。

**同源策略：** 是为了保护用户的隐私和数据安全的一种浏览器行为。若缺少同源策略，容易被恶意网站通过脚本非法获取其他网站上的敏感数据，故浏览器用同源策略来限制不同源之间的直接通信。

**同源策略限制范围：**
+ **DOM同源策略**：禁止脚本读取或修改不同源页面的DOM。
+ **cookie、localStorage、indexedDB访问**：禁止脚本访问不同源的存储数据。
+ **XMLHttpRequest**：禁止向不同源的服务器发送AJAX请求。

ps：script、img、link等标签不受同源策略限制，虽然都可以加载跨域资源，但浏览器限制了js的权限使其不能读写加载的内容，故引入的文件不会被客户端js获取，故无影响。

### **跨域** 
**定义：** 协议、域名、端口号其中任意一项不同均属于不同源，跨域是非同源请求，是浏览器根据同源策略对请求的限制。

**跨域的场景**
+ **XMLHttpRequest或Fetch发起的跨源HTTP请求**
+ **Web字体（css中通过@font-face使用跨源字体资源）**
+ **WebGL贴图**
+ **使用drawImage将images/video绘制到canvas**
+ **样式表、脚本等**

**跨域产生的条件：** 由于浏览器同源策略的限制，浏览器会拒绝跨域请求。

# 解决跨域的方法
## 一、跨域资源共享（CORS）
通过在HTTP请求和响应中加入特定的头部信息来工作，从而允许或拒绝跨域请求。核心是后端通过```Access-Control-Allow-Origin```设置响应头来指定允许的域名，以此来通知浏览器此时的同源策略不生效.

**CORS请求类型**

+ **简单请求：**
简单请求的特点是使用GET、HEAD、POST方法，HTTP请求头信息限于几个限定字段，浏览器直接发送请求。服务器至少需要配置```Access-Control-Allow-Origin```字段。
+ **非简单请求：**
使用GET、POST、HEAD以外的请求方法，或者POST请求中包含非标准的内容类型、自定义请求头等。
  + 预检请求（OPTIONS请求）：在正式通信之前的HTTP请求，浏览器会询问服务器，当前页面所在域名是否在服务器的许可名单之中，以及使用哪些HTTP动词和头部信息段。只有得到肯定答复，浏览器才会正式发请求。
  + 请求头字段说明
    + Access-Control-Allow-Origin：必须。它的值是请求时Origin字段的值，或者是一个*，表示接受任意域名的请求
    + Access-Control-Request-Method：必须。用来列出浏览器的CORS请求会用到哪些HTTP方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次"预检"请求。
    + Access-Control-Request-Headers：必须。该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。
    + Access-Control-Allow-Credentials：可选。表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。
    + Access-Control-Expose-Headers：可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language
    + Access-Control-Max-Age：可选。指定本次预检请求的有效期，单位为秒。可以用来缓存预检结果，避免每次请求都发送OPTIONS请求，
    + Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。
  + Cookie处理（在CORS请求中携带Cookie）
    + 客户端（如通过XMLHttpRequest或Fetch API）需设置withCredentials属性为true，表明请求需要携带凭据（如Cookie）。
    + 服务器响应中必须设置Access-Control-Allow-Credentials为true，表明服务器允许浏览器携带Cookie。
    + Access-Control-Allow-Origin不能设为星号*，而应指定具体的源地址，因为星号不允许与Access-Control-Allow-Credentials: true一起使用。

CORS优点：支持所有类型的HTTP请求。使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。
## 二、通过jsonp跨域
+ script标签引入的js不受同源策略的限制，可以借此来发送请求。
+ 给后端携带一个参数 callback 并在前端定义 callback 函数体
+ 后端返回 callback 的调用形式并将要响应的值作为 callback 的函数参数。
+ 当浏览器接收到响应后，会触发全局的 callback 函数，从而让 callback 以参数的形式接收后端的响应。

**例子**
```html
// 前端代码
<script>
    function jsonp(url, callbackName) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
    
            // 设置脚本标签的src属性为请求的URL，并附加一个回调参数
            script.src = `${url}?callback=${callbackName}`;
    
            // 将脚本标签添加到body中，触发异步请求
            document.body.appendChild(script);

            // 注册一个全局的回调函数
            window[callbackName] = function(data) {
                resolve(data);
                document.removeChild(script)
            }
        });
    }

    // 使用jsonp函数发起请求
    jsonp('http://localhost:3000', 'callback').then(res => {
        // 在控制台输出结果
        console.log(res)
    })
</script>
```
```js
// 后端代码
const http = require('http');

// 创建一个HTTP服务器实例，并指定一个处理请求的回调函数
http.createServer(function(req, res) {
    // 解析请求的URL，并获取咨询参数
    const query = new URL(req.url, `http://${req.headers.host}`).searchParams;
    
    
    // 检查咨询参数中是否包含回调函数 callback
    if (query.get('callback')) {
        // 获取回调函数名
        const callabckName = query.get('callback');
        
        // 准备要返回的参数
        const data = 'hello world';
        
        // 构成JSONP格式的字符串，格式为 callback('hello world')
        const result = `${callabckName}("${data}")`;
        res.end(result);
    }
}).listen(3000); 
```
缺点：只支持Get请求，易受到XSS（跨域脚本攻击）的威胁
## 三、WebSocket协议跨域

## 四、nginx代理跨域

## 五、nodejs中间件代理跨域

## 六、postMessage跨域

## 七、document.domain + iframe跨域

## 八、location.hash + iframe跨域

## 九、window.name + iframe跨域



