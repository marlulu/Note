#                   跨域

------
# 前言：跨域与同源策略
### **同源** 
**定义：** 页面的协议，域名和端口都相同，则为同一源，否则为非同一源。

**同源策略：** 是为了保护用户的隐私和数据安全的一种浏览器行为。若缺少同源策略，容易被恶意网站通过脚本非法获取其他网站上的敏感数据，故浏览器用同源策略来限制不同源之间的直接通信。

**同源策略限制范围：**
+ **DOM同源策略**：禁止脚本读取或修改不同源页面的DOM。
+ **cookie、localStorage、indexedDB访问**：禁止脚本访问不同源的存储数据。
+ **XMLHttpRequest**：禁止向不同源的服务器发送AJAX请求。

ps：script、img、link等标签不受同源策略限制，虽然都可以加载跨域资源，但浏览器限制了js的权限使其不能读写加载的内容，故引入的文件不会被客户端js获取，故无影响。

### **跨域** 
**定义：** 协议、域名、端口号其中任意一项不同均属于不同源，跨域是非同源请求，是浏览器根据同源策略对请求的限制。

**跨域的场景**
+ **XMLHttpRequest或Fetch发起的跨源HTTP请求**
+ **Web字体（css中通过@font-face使用跨源字体资源）**
+ **WebGL贴图**
+ **使用drawImage将images/video绘制到canvas**
+ **样式表、脚本等**

**跨域产生的条件：** 由于浏览器同源策略的限制，浏览器会拒绝跨域请求。

# 解决跨域的方法
## 一、跨域资源共享（CORS）
通过在HTTP请求和响应中加入特定的头部信息来工作，从而允许或拒绝跨域请求。核心是后端通过```Access-Control-Allow-Origin```设置响应头来指定允许的域名，以此来通知浏览器此时的同源策略不生效.

**CORS请求类型**

+ **简单请求**
简单请求的特点时
+ **非简单请求**

## 二、通过jsonp跨域
+ script标签引入的js不受同源策略的限制，可以借此来发送请求。
+ 给后端携带一个参数 callback 并在前端定义 callback 函数体
+ 后端返回 callback 的调用形式并将要响应的值作为 callback 的函数参数。
+ 当浏览器接收到响应后，会触发全局的 callback 函数，从而让 callback 以参数的形式接收后端的响应。

**例子**
```html
// 前端代码
<script>
    function jsonp(url, callbackName) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
    
            // 设置脚本标签的src属性为请求的URL，并附加一个回调参数
            script.src = `${url}?callback=${callbackName}`;
    
            // 将脚本标签添加到body中，触发异步请求
            document.body.appendChild(script);

            // 注册一个全局的回调函数
            window[callbackName] = function(data) {
                resolve(data);
                document.removeChild(script)
            }
        });
    }

    // 使用jsonp函数发起请求
    jsonp('http://localhost:3000', 'callback').then(res => {
        // 在控制台输出结果
        console.log(res)
    })
</script>
```
```js
// 后端代码
const http = require('http');

// 创建一个HTTP服务器实例，并指定一个处理请求的回调函数
http.createServer(function(req, res) {
    // 解析请求的URL，并获取咨询参数
    const query = new URL(req.url, `http://${req.headers.host}`).searchParams;
    
    
    // 检查咨询参数中是否包含回调函数 callback
    if (query.get('callback')) {
        // 获取回调函数名
        const callabckName = query.get('callback');
        
        // 准备要返回的参数
        const data = 'hello world';
        
        // 构成JSONP格式的字符串，格式为 callback('hello world')
        const result = `${callabckName}("${data}")`;
        res.end(result);
    }
}).listen(3000); 
```
缺点：只支持Get请求，易受到XSS（跨域脚本攻击）的威胁
## 三、WebSocket协议跨域

## 四、nginx代理跨域

## 五、nodejs中间件代理跨域

## 六、postMessage跨域

## 七、document.domain + iframe跨域

## 八、location.hash + iframe跨域

## 九、window.name + iframe跨域



